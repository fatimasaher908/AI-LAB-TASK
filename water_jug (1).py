# -*- coding: utf-8 -*-
"""Water_Jug.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1tw8hsN95I2-9cSnEqNkFQ9PgAqPh9k6H
"""

from collections import deque

# Capacities of the two jugs
JUG1 = 4
JUG2 = 3

# Goal: we want exactly 1 liter in either jug
GOAL = 1

def water_jug_bfs():
    start = (0, 0)              # Start with both jugs empty
    visited = set()             # To keep track of visited states
    queue = deque([[start]])    # Queue stores paths (not just states)

    while queue:
        path = queue.popleft()     # Get the current path
        state = path[-1]           # Get the last state in the path
        x, y = state               # x = water in jug1, y = water in jug2

        # Check if we've reached the goal
        if x == GOAL or y == GOAL:
            return path            # Return the successful path

        # Skip if already visited
        if state in visited:
            continue
        visited.add(state)

        # All possible next states (actions we can take)
        next_states = [
            (JUG1, y),  # Fill Jug1 completely
            (x, JUG2),  # Fill Jug2 completely
            (0, y),     # Empty Jug1
            (x, 0),     # Empty Jug2
            # Pour Jug1 â†’ Jug2
            (x - min(x, JUG2 - y), y + min(x, JUG2 - y)),
            # Pour Jug2 â†’ Jug1
            (x + min(y, JUG1 - x), y - min(y, JUG1 - x))
        ]

        # Add next states to the queue if not visited
        for nxt in next_states:
            if nxt not in visited:
                new_path = list(path)
                new_path.append(nxt)
                queue.append(new_path)

    return None  # If no solution found

# Run the BFS and print the solution path
solution = water_jug_bfs()
print("BFS Solution path:")
for step in solution:
    print(step)

def water_jug_dfs():
    start = (0, 0)              # Both jugs are initially empty
    stack = [[start]]           # DFS uses a stack; each item is a path (list of states)
    visited = set()             # To keep track of visited states and avoid loops

    while stack:
        path = stack.pop()      # Take the most recent path from the stack
        state = path[-1]        # Current state is the last in the path (x, y)

        # Check if either jug has the desired amount
        if state[0] == GOAL or state[1] == GOAL:
            return path         # If goal is reached, return the path

        # Skip if already visited
        if state in visited:
            continue
        visited.add(state)      # Mark current state as visited

        x, y = state            # x = amount in Jug1, y = amount in Jug2

        # All possible next moves:
        next_states = [
            (JUG1, y),  # Fill Jug1
            (x, JUG2),  # Fill Jug2
            (0, y),     # Empty Jug1
            (x, 0),     # Empty Jug2
            # Pour from Jug1 to Jug2
            (x - min(x, JUG2 - y), y + min(x, JUG2 - y)),
            # Pour from Jug2 to Jug1
            (x + min(y, JUG1 - x), y - min(y, JUG1 - x))
        ]

        # For each possible move, if it's new, add it to the stack
        for nxt in next_states:
            if nxt not in visited:
                new_path = list(path)  # Copy current path
                new_path.append(nxt)   # Add the new state
                stack.append(new_path) # Push the new path into the stack

    return None  # Return None if no solution found

# Run the DFS and print the steps
solution = water_jug_dfs()
print("DFS Solution path:")
for step in solution:
    print(step)

import heapq

# Heuristic function: estimate how close we are to the goal
# It returns the minimum distance (in liters) from either jug to the goal
def heuristic(state):
    x, y = state
    return min(abs(x - GOAL), abs(y - GOAL))

def a_star_water_jug():
    start = (0, 0)  # Starting with both jugs empty

    # Priority queue (min-heap) to store: (f = g + h, g, path)
    open_list = []
    heapq.heappush(open_list, (heuristic(start), 0, [start]))

    visited = {}  # Dictionary to track the lowest cost to reach each state

    while open_list:
        f, g, path = heapq.heappop(open_list)  # f = total estimated cost, g = steps so far, path = full route
        state = path[-1]  # Current state is the last in the path

        # Check if either jug has exactly the GOAL amount
        if state[0] == GOAL or state[1] == GOAL:
            return path  # Goal reached â€” return path

        # Skip if already visited with equal or lower cost
        if state in visited and visited[state] <= g:
            continue
        visited[state] = g  # Mark as visited with current cost

        x, y = state  # Current amounts in jug1 and jug2

        # All possible valid next states (actions you can take)
        next_states = [
            (JUG1, y),  # Fill Jug1
            (x, JUG2),  # Fill Jug2
            (0, y),     # Empty Jug1
            (x, 0),     # Empty Jug2
            # Pour Jug1 â†’ Jug2
            (x - min(x, JUG2 - y), y + min(x, JUG2 - y)),
            # Pour Jug2 â†’ Jug1
            (x + min(y, JUG1 - x), y - min(y, JUG1 - x))
        ]

        for nxt in next_states:
            # Check if this path is better than any previously found
            if nxt not in visited or g + 1 < visited.get(nxt, float('inf')):
                new_path = list(path)     # Copy current path
                new_path.append(nxt)      # Add new state
                new_g = g + 1             # Increment steps
                new_f = new_g + heuristic(nxt)  # f = g + h
                heapq.heappush(open_list, (new_f, new_g, new_path))

# Define constants
JUG1 = 4     # Jug 1 capacity
JUG2 = 3     # Jug 2 capacity
GOAL = 1     # Desired water amount

# Run A* algorithm and print the result
solution = a_star_water_jug()
print("A* Solution path:")
for step in solution:
    print(step)

"""Compare the solution paths found by BFS, DFS, and A*. **bold text**
Comparison of BFS, DFS, and A* Search Algorithms (Water Jug Problem)

Breadth-First Search (BFS)
Solution Path: Always finds the shortest path to the goal because it explores states level by level.

Optimality: Guarantees the shortest solution path.

Time Complexity: ð‘‚ ( ð‘ ð‘‘ ) O(b d ), where ð‘ b is the branching factor and ð‘‘ d is the depth of the shallowest solution.

Space Complexity: ð‘‚ ( ð‘ ð‘‘ ) O(b d ), as all nodes at the current level are stored in memory.

Efficiency: Effective for small state spaces but memory-intensive for larger problems.

Depth-First Search (DFS)
Solution Path: May find a solution but not necessarily the shortest one, as it explores one branch deeply before backtracking.

Optimality: Not guaranteed to return the shortest path.

Time Complexity: ð‘‚ ( ð‘ ð‘š ) O(b m ), where ð‘š m is the maximum depth of the search tree.

Space Complexity: ð‘‚ ( ð‘ ð‘š ) O(bm), as it only stores the current path and unexplored siblings.

Efficiency: Memory-efficient, but can be time-inefficient, especially if the goal lies at shallow depth while the algorithm explores deep irrelevant paths.

A* Search Algorithm
Solution Path: Finds the shortest path using a heuristic to guide the search.

Optimality: Guarantees optimal solution if the heuristic is admissible (never overestimates the cost).

Time Complexity: ð‘‚ ( ð‘ ð‘‘ ) O(b d ) in the worst case, but usually explores fewer states than BFS due to heuristic guidance.

Space Complexity: Higher than DFS, as it maintains both open and closed lists, but typically better than BFS for large problems.

Efficiency: More efficient than BFS in practice because it prioritizes promising states, reducing unnecessary exploration.

Which algorithm gives the shortest path? Why? BFS and A* both give the shortest path (3 steps).

BFS guarantees shortest because it explores level by level.

A* guarantees shortest if the heuristic is admissible (never overestimates the cost).

Which algorithm is more efficient in terms of time and memory? DFS is memory-efficient (keeps fewer states), but not time-efficient since it may wander into long, irrelevant paths.

BFS is time-efficient for small problems but memory-hungry as it stores all nodes at each depth.

A* is generally the most efficient in practiceâ€”it balances between BFS (guaranteed shortest) and DFS (low memory) by using heuristics to guide the search.
"""